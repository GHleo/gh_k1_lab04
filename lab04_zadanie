Лабораторная работа 4.

Исследование функций.
Цели работы:
получение более эффективных расчетных соотношений для вычисления таблицы значений функции;
форматирование потокового вывода;
определение с заданной точностью характерных точек функции.

Задание.
1. Преобразовать исходное выражение с целью уменьшения числа операций, требующихся для вычисления значения функции. Это имеет смысл сделать, так как при табулировании функции она вычисляется многократно.
2. Вычислить и вывести на экран таблицу значений функции одной переменной и соответствующих значений аргумента. Аргумент функции меняется от XN до XK включительно с шагом DX.
Величины XN, XK и DX выбрать так, чтобы вычислить порядка 15 значений функции (чтобы таблица результатов помещались на экран) на участке, где она не имеет разрывов, и в одной из точек её значение легко проконтролировать.
3. Представить результаты п.2 в виде форматированной таблицы, в которой:
- число выводимых разрядов для значений функции равно12 плюс знак (знак ‘+’ не выводить);
- значения X и Y расположить в два столбца шириной 10 и 18 знаков соответственно (см. Приложение 1).
4. Используя программу табулирования функции, исследовать функцию в широком диапазоне изменения Х на предмет наличия корней, экстремумов и точек разрыва. Исследование выполните путем ввода подходящих значений XN, XK и DX, анализа  полученных значений функции и уточнения, если требуется, введенных значений XN, XK и DX. Выбрать интервал, где имеется ровно один экстремум или корень (если функция не имеет экстремумов).
5. Используя результаты п.4, определить с заданной точностью значение функции в выбранной характерной точке. Для определения экстремума (или корня) разработайте программу, которая реализует следующий итерационный алгоритм:
Х изменяется от XN к XK с шагом DX (искомая точка находится внутри заданного интервала) ;
при прохождении искомой точки выполняется возврат на один шаг назад;
устанавливаются новые значения XN, XK и шаг DX уменьшается в 10 раз.
Пункты 1, 2 и 3 повторяются до тех пор, пока  DX > 0.000001.


Требования к отчету
Отчет по лабораторной работе должен состоять из 4-х разделов, отражающих основные этапы разработки программы:
- Постановка задачи;
Разработка алгоритма;
- Кодирование (соответствующий раздел отчета называется «Текст программы»);
- Тестирование (соответствующий раздел отчета называется «Анализ результатов»).
В разделе «Постановка задачи» должен быть приведен текст задания.
Раздел «Разработка алгоритма» должен содержать расчетное выражение для табулирования функции (п.3 задания), укрупненную схему алгоритма исследования функции (один алгоритм, включающий п.4 и п.5 задания) и уточненную блок-схему алгоритма для п.5 задания.
В разделе «Текст программы» должен быть приведен листинг программы, включающий необходимые комментарии.
В разделе «Анализ результатов» должна быть приведена распечатка экрана, содержащая таблицу для выбранного интервала и значение функции в характерной точке. Для экономии краски изображение экрана должно иметь белый фон.
Отчет должен быть распечатан на принтере на листах бумаги формата А4, скрепленных в левом верхнем углу с помощью степлера, и подписан исполнителем с указанием даты сдачи отчета преподавателю.


Варианты заданий.

№
Выражение для функции
1
log 2.1 [ (tg(x/2) + 2 – √¯3 ) /  (tg(x/2) + 2 + √¯3 ) ] / √¯3
2
3 tg(x) – tg 2 (x) /3
3
[√¯x  * sin(x) + x] / (x + e x)
4
4.85 + 10 -5 * sin(x 2) / {√¯ [(x2 + 1)3 -1] +1}
5
√¯ (1+x) + cos(2x) / √¯ [1+lg(x 12 +1)]
6
[e sin(x) * sin(x) * sin(x) + ln( arctg(x) )] / sin (x)
7
{[x + cos(x) + 2] / (2x)}4 – x / [x + 3sin(x) – 3]
8
sin 3 (x/5) * cos(x2) + lg(x) / √¯ [x + x3 / ln(x)]
9
lg( tg( x/2)) – cos(x) / sin2 (x)
10
{sin4(x) – 1 + (3.089 x4 – 2) / [1 + (x-1)/(x3 +1)]}2
11
3sin(x) + x4 * [1 + (x–2/x) / (x+2/x)] * sin (x) -1
12
√¯(x2+1)- log3{[1+√¯(x2+1)]/x}
13
[ex*x +√¯|cos(x)|] / [1+ex*x*x  * |cos(x)|]
14
[3 sin(3x) – cos(3x)] * e-sin(x) * sin(x)
15
1 + x + x2/2 +x3/6 + x4/24 + x5/120 + x6/720 + x7/5040 - ex
16
1 – x2/2 + x4/24 – x6/720 + x8/40320 – cos(x)
17
0.693147 + 2 * {x / ((4+x) + x3 / [3*(4+x)3] + x5 / [5*(4+x)5]}
18
1+x/24 + x2/40320 + x0.25 *(1+x/120 + x2/362880) + x1/2 *(1+x/60)/2 +x5/4 *(1+x/840)/6 - e√¯√¯x
19
x6 – 15x5 + 69x4 – 185x3 + 414x2 – 540x + 216 + 1/(x2 – 5x +5)
20
8*[log5(x2+3x+2)]2 + 9*log5(x2+3x+2) - 5
21
sin(x) * sin(x/2) / [1 – cos2(x/2)]
22
2 sin(x) – ln2 (x) /5
23
tg( ln( x/3)) – sin(x) / cos2 (x)
24
1 – x + x3/6 – x5/120 –sin(x)
25
e2x – x*x / 2 - 2
Приложение 1
Форматирование данных при обменах с потоками
Для управления форматом вывода (включения в поток) класс ios имеет следующие компоненты:
компонент (атрибут) x_f lags и функции доступа к атрибуту x_f lags:
 flags () – показать флаги форматирования и
 setf () – установить флаги форматирования;
атрибуты    управления    форматом:    x_width,    x_precision,  x_fill
и функции доступа к этим атрибутам:    width (),    precision (),  fill();
манипуляторы (вставляемые в цепочки обмена).
Наиболее простой способ изменения параметров и флагов форматирования обеспечивают манипуляторы. Их мы и будем использовать при выполнении лабораторных работ. Но для понимания правил их использования следует ознакомиться с атрибутами и функциями класса ios, предназначенными для форматирования данных при обменах с потоками.
Форматирование пересылаемых данных. Непосредственное применение операций вывода << (включение в поток) и ввода >> (извлечение из потока) к стандартным потокам cout, cin, cerr, clog для данных базовых типов приводит к использованию "умалчиваемых" форматов внешнего представления пересылаемых значений. Например, при выводе чисел каждое из них занимает ровно столько позиций, сколько необходимо для его представления. Это не всегда удобно и правильно. Например, выполнение операторов
int i1 = 1, i2 = 2, i3 = 3, i4 = 4, i5 = 5;
cout << "\n" << i1 << i2 <<i3 << i4 << i5;
приведет к такому результату:
12345
Для улучшения читаемости проще всего явно ввести разделительные пробелы. Выполнив оператор
cout <<  "\n" << i1 << '    ' << i2 << '    ' <<  i3 << '    ‘ <<  i4 << '    ' <<  i5;
получим более наглядный результат:
1   2   3   4   5
Следующий шаг - добавление пояснительного текста и (или) символов табуляции. Эти приемы мы уже неоднократно применяли в программах, но никак не изменяли формат самих выводимых значений. Ширина (количество позиций) внешнего представления каждого числа выбирается автоматически, исходя из необходимого количества позиций. Единообразие не всегда устраивает пользователя программы. Например, периодическую дробь 1.0 / 3.0 можно представить весьма различными способами:
0.3     0.3333   3.3е-1     0.3333333е0
Однако стандартное представление при выводе с помощью оператора
cout <<   "\n1.0   /   3.0  =   “  <<  1.0   /   3.0;
будет всегда одинаковым (6 знаков после запятой):
1.0  /  3.0 = 0.333333
Такое поведение выходного потока при использовании операции включения со значением типа double предусматривается по умолчанию. Форматы представления выводимой информации и правила восприятия данных, вводимых из потока, могут быть изменены программистом с помощью флагов форматирования. Эти флаги унаследованы всеми потоками библиотеки из базового класса ios. Флаги реализованы в виде отдельных фиксированных битов чисел типа long, поэтому несколько флагов с помощью логических битовых выражений можно объединять, тем самым по-разному комбинируя свойства потока. Перечислим флаги форматирования, объясняя их действия для тех значений, которые указаны справа от знаков присваивания:
skipws  =  0x0001
при таком значении флага операция извлечения из потока >> будет игнорировать (пропускать) обобщенные пробельные символы;
left  =  0x0002
вывод значения с левым выравниванием (прижать к левому краю поля);
right =  0x0004
вывод значения с правым выравниванием (это значение устанавливается по умолчанию);
internal  =  0x0008
принятый в качестве заполнителя символ (по умолчанию пробел) помещается между числовым значением и знаком числа либо признаком основания системы счисления (см. ниже компонент ios: :x_f ill);
dec  =  0x0010
десятичная система счисления;
oct = 0x0020
восьмеричная система счисления;
hex =  0x0040
шестнадцатеричная система счисления;
showbase   =  0x0080
напечатать при выводе признак системы счисления (0х для шестнадцатеричных чисел, 0 - для восьмеричных чисел);
showpoint =  0x0100
при выводе вещественных чисел обязательно печатать десятичную точку и следующие за ней нули (даже для вещественного числа, имеющего нулевую дробную часть);
uppercase =  0x0200
при выводе чисел использовать буквы верхнего регистра: символ X и буквы abcdef для шестнадцатеричных цифр, указатель порядка е для чисел с плавающей точкой;
showpos  =  0x0400
печатать знак числа (символ ' + ') при выводе положительных чисел;
scientific =  0x0800
для вещественных чисел (типов float, double) использовать представление в формате с плавающей точкой (научное представление), т.е. с указанием порядка и мантиссы, имеющей одну ненулевую (значащую) цифру перед точкой;
fixed =  0x1000
для вещественных чисел (типов float, double) использовать представление в формате с фиксированной точкой, причем количество цифр дробной части определяется заданной по умолчанию точностью (см. ниже переменную x_precision);
unitbuf =  0x2000
очищать все потоки (выгрузить содержимое буферов) после каждого вывода (после включения в поток);
stdio = 0x4000
очищать потоки stdout, stderr (выгрузить содержимое буферов) после каждого вывода (после включения в поток).
Все флаги форматирования в виде отдельных фиксированных битов входят в компонент (свойство) класса ios:
long x_flags; // Переменная представления флагов форматирования
Именно эта переменная, относящаяся к конкретному потоку, анализируется при обменах и влияет на преобразование информации. В библиотеке классов ввода-вывода существуют принадлежащие классу ios функции flags () и setf () для проверки значений перечисленных флагов, для установки флагов и для их сбрасывания в исходные (умалчиваемые) состояния.
Манипуляторы. Несмотря на гибкость и большие возможности управления форматами с помощью компонентных функций класса ios, их применение достаточно громоздко. Более простой способ изменения параметров и флагов форматирования обеспечивают манипуляторы.
Манипуляторами называют специальные функции, позволяющие программисту изменять состояния и флаги потока. Особенность манипуляторов и их отличие от обычных функций состоит в том, что их имена (без параметров) и вызовы (с параметрами) можно использовать в качестве правого операнда для операции обмена (<< или >>). В качестве левого операнда в этом выражении, как обычно, используется поток (ссылка на поток), и именно на этот поток оказывает влияние манипулятор.
Например, манипулятор hex позволяет устанавливать шестнадцатеричное основание счисления выводимых в поток cout числовых значений. Выполнив последовательность операторов:
cout << "\пДесятичное  число:   "<<  15  << hex;
cout << "\пШестнадцатеричное представление:   "<< 15;
получим на экране:
Десятичное  число:   15
Шестнадцатеричное представление:   0xF
Как наглядно показывает результат, применение манипулятора hex изменило одно из свойств потока cout. Десятичная целая константа 15 воспринимается и выводится на экран в шестнадцатеричном виде.
В качестве примера каждый манипулятор автоматически (без явного участия программиста) получает ссылку на тот поток, с которым он используется в выражении. После выполнения манипулятора он возвращает ссылку на тот же поток. Поэтому манипуляторы можно использовать в цепочке включений в поток или извлечений из потока. При выполнении манипулятора никаких обменов данными с потоком не происходит, но манипулятор изменяет состояние потока. Например, выполнив оператор с манипуляторами hex, oct, dec:
cout <<  15 <<  hex <<  15  <<  oct <<  15  <<  dec<<  15;
в качестве результата получим:
150xF01715
Манипуляторы библиотеки классов ввода-вывода языка Си++ делятся на две группы: манипуляторы с параметрами и манипуляторы без параметров.
Манипуляторы без параметров:
dec - при вводе и выводе устанавливает флаг десятичной системы счисления;
hex - при вводе и выводе устанавливает флаг шестнадцатеричной системы счисления;
oct - при вводе и выводе устанавливает флаг восьмеричной системы счисления;
ws - действует только при вводе и предусматривает извлечение из входного потока пробельных символов (пробел, знаки табуляции '\t’ и ' \v’, символ перевода строки '\n', символ возврата каретки '\r', символ перевода страницы’ \f’);
endl    - действует только при выводе, обеспечивает включение в выходной поток символа новой строки и сбрасывает буфер (выгружает содержимое) этого потока;
ends    - действует только при выводе и обеспечивает включение в поток нулевого признака конца строки;
flush - действует только при выводе и очищает выходной поток, т.е. сбрасывает его буфер (выгружает содержимое буфера).
left  - вывод значения с левым выравниванием (прижать к левому краю поля);
right - вывод значения с правым выравниванием (это значение устанавливается по умолчанию);
fixed - для вещественных чисел (типов float, double) используется представление в формате с фиксированной точкой, причем количество цифр дробной части определяется заданной точностью.
Обратите внимание, что не все перечисленные манипуляторы действуют как на входные, так и на выходные потоки, ws действует только при вводе; endl, ends, flush - только при выводе.
Манипуляторы dec, hex, oct, задающие основание системы счисления, изменяют состояние потока, и это изменение остается в силе до следующего явного изменения.
Манипулятор endl рекомендуется использовать при каждом выводе, который должен быть незамедлительно воспринят пользователем. Например, его использование просто необходимо в таком операторе:
cout <<   "Ждите!   Идет набор статистики."  << endl ;
При отсутствии endl здесь нельзя гарантировать, что сообщение пользователю не останется в буфере потока cout до окончания набора статистики.
Манипуляторы с параметрами определены в файле iomanip:
setbase(int n);
устанавливает основание (n) системы счисления. Значениями параметра n могут быть: 8, 10 или 16.
resetiosflags(long L)
сбрасывает (очищает) отдельные флаги состояния потоков ввода и вывода на основе битового представления значения параметра L (сбрасывает флаги в соответствии с единичными битами);
setiosflags(long L)
устанавливает отдельные флаги состояния (форматные биты) потоков ввода-вывода на основе битового представления значения параметрах (устанавливаются флаги в соответствии с единичными битами параметра);
setfill(int n)
значение параметра n в дальнейшем используется в качестве кода символа-заполнителя, который помещается в незанятых позициях поля при вводе значения.
setprecision(int n)
определяет с помощью значения параметра n точность представления вещественных чисел, т.е. максимальное количество цифр дробной части числа при вводе и выводе.
setw(int n)
значение параметра n задает минимальную ширину поля вывода.
С помощью манипуляторов можно управлять представлением информации в выходном потоке. Например, манипулятор setw(int n) позволит выделить для числового значения поле фиксированной ширины, что удобно при печати таблиц.
